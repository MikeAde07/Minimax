# import sys module
import sys


# instantiate the class RedBlueNim
class RedBlueNim :
  # instantiate the constructor method
  def __init__(self, num_red, num_blue) :
    # initialize instance variables
    self.num_red = num_red
    self.num_blue = num_blue
    # initialize variable, current player not yet determined
    self.current_player = None

  def generate_successor_states(self) :
    """Generates all pssoible moves from the current state of the game"""
    # initialize empty list to store successor states of the current game state
    successor_states = []
    # iterates over each color in combination for picking 1 or 2 marbles from each pile
    for color in ['red', 'blue'] :
      for i in range(1,3) :
        # checks if current color is red and if enough marbles to pick 'i' marbles
        if color == 'red' and self.num_red >= i :
          successor_states.append((self.num_red - i, self.num_blue, f"Pick {i} red marble"))
        # checks if current color is blue and if enough marbles to pick 'i' marbles
        elif color == 'blue' and self.num_blue >= i :
          successor_states.append((self.num_red, self.num_blue - i, f"Pick {i} blue marble"))
    return successor_states

  def evaluate_states(self) :
    """Evalues the current state of the game to determine the score or value of the state"""
    # checks if the red or blue pile is empty
    if self.num_red == 0 or self.num_blue == 0 :
      #checks if computer is the current player and red pile is empty (standard)
      if self.current_player == 'computer' and self.num_red == 0 :
        return -2 * self.num_blue
        #checks if computer is the current player and blue pile is empty (misere)
      elif self.current_player == 'computer' and self.num_blue == 0 :
        return -3 * self.num_red
      # checks if human is the current player and if red pile is empty (standard)
      elif self.current_player == 'human' and self.num_red == 0 :
        return 2 * self.num_blue
      # checks if human is the current player and if blue pile is empty (misere)
      elif self.current_player == 'human' and self.num_blue == 0 :
        return 3 * self.num_red
      #if none of the above conditions are met, the game is still in progress
    return 0

  def minimax_alpha_beta (self, maximizing_player) :
    """minimax algorithm with alpha-beta pruning to determine the optimal move for the computer player"""
    # checks if red or blue pile is empty
    if self.num_red == 0 or self.num_blue == 0 :
      return self.evaluate_states()

    # checks if current player is maximizing their score
    if maximizing_player :
      # initializes max eval value to negative infinity, value is updated through successor states
      max_eval = -sys.maxsize
      # iterates over possible successor states
      for move in self.generate_successor_states():
        self.num_red, self.num_blue, _= move
        self.current_player = 'computer'
        # recursive call to evaluate opponent's moves
        eval = self.minimax_alpha_beta(False)
        # updates 'max_eval' to current value and the evaluation of the current state
        max_eval = max(max_eval, eval)
      return max_eval

      # minimizing players turn
    else :
      min_eval = sys.maxsize
      for move in self.generate_successor_states():
        self.num_red, self.num_blue, _= move
        self.current_player = 'human'
        eval = self.minimax_alpha_beta(True)
        min_eval = min(min_eval, eval)
      return min_eval

  def prompt_human_move(self) :
    """prompts the human player to choose a move from the list of valid moves"""
    # initialize empty list
    valid_moves = []
    # iterates over possible successor states generated by 'generate_successor_states' method
    for successor in self.generate_successor_states() :
      _, _, move = successor
      valid_moves.append(move)
    print("Valid moves:", valid_moves)
    # prompts human player to enter the index of the move they want to make
    move_index = int(input("Choose move index: "))
    return valid_moves[move_index]

  def play_game(self, version='standard', first_player = 'computer') :
    """alternates between the computer and human players' turn until pile becomes empty. Uses minimax algorithm to implement alpha-beta pruning"""
    # sets the current player based on the first player argument
    if first_player == 'computer' :
      self.current_player = 'computer'
    else :
      self.current_player = 'human'

    # loop continues until the game ends
    while True :
      if self.current_player == 'computer' :

        # generates valid moves based on the game version, order of moves are reversed if it's the 'misere' version
        if version == 'standard' :
          moves = self.generate_successor_states()
        else :
          moves = self.generate_successor_states()[::-1]

        
        # iterates over the generated moves, evaluates each move using the minmax algorithm with alpha-beta pruning, and selects the move with the highest eval score
        best_move = None
        best_eval = -sys.maxsize
        for move in moves :
          self.num_red, self.num_blue, _= move
          eval = self.minimax_alpha_beta(False)
          if eval > best_eval :
            best_eval = eval
            best_move = move

        print("Computer's move:", best_move[2])
        self.num_red, self.num_blue, _= best_move
      else :
        move = self.prompt_human_move()
        if 'red' in move :
          self.num_red -= int(move.split()[1])
        else :
          self.num_blue -= int(move.split()[1])

      # checks if either pile is empty and determines the winner based on the game version and current player
      winner = None
      if self.num_red == 0 or self.num_blue == 0 :
        if version == 'standard' :
          if self.current_player == 'computer' :
            winner = 'human'
          else :
            winner = 'computer'
        else :
          if self.current_player == 'computer' :
            winner = 'computer'
          else :
            winner = 'human'
        break

      if self.current_player == 'computer' :
        self.current_player = 'human'
      else :
        self.current_player = 'copmuter'

    if winner == 'computer' :
      print("Computer wins!")
    elif winner == 'human' :
      print("Human wins!")
    else :
      print("It's a draw!")

    print(f"Final state: {self.num_red} red marbles, {self.num_blue} blue marbles")

if __name__ == "__main__" :
  num_red = int(input("Enter the number of red marbles: "))
  num_blue = int(input("Enter the number of blue marbles: "))
  version = input("Enter game version (standard/misere): ").lower()
  first_player = input ("Enter first player (computer/human): ").lower()

  # game initialization and execution
  game = RedBlueNim(num_red, num_blue)
  game.play_game(version, first_player)